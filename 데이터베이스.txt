3. 데이터베이스의 정의 및 특성
	
	데이터베이스의 정의
		1. 통합된 데이터 : 중복을 최소화 물리적으로 떨어져 있어도 논리적으로는 통합
		2. 저장된 데이터 
		3. 운영 데이터 : 업무를 위한 목적
		4. 공용 데이터 : 공동으로 사용됨 > 문제발생 동시에

	데이터베이스의 특성
		1. 실시간 접근성 : 수초 내, 리얼타임 제공 필요
		2. 계속적인 변화 : 시간에 따라 항상 바뀐다
		3. 동시 공유 : "여러 사용자"에게 동시에 공유, 순번을 받고 대기하는 일은 없어야함
		4. 내용에 따른 참조 : 물리적으로 저장되는 위치가 아니라 데이터 값에 따라 참조 키워드 만으로 모든 내용을 읽을 수 있어야 함

4. 데이터베이스 시스템의 구성

	데이터베이스 사용자 : 일반 사용자/ 응용 프로그래머/ SQL 사용자/ 관리자
	데이터베이스 시스템 : DBMS(사용자-데이터베이스 연결시켜주는 소프트웨어, 유형)/ 데이터베이스(데이터를 모아둔 토대, 무형)/ 데이터모델(데이터가 저장되는 기법에 관한 내용)


문제를 분해하는 것 중요
 
파일 시스템 일치 문제 발생 > DB 통합이 최선



DBMS - MYSQL 오라클

원칙 : 서버(제공하는 쪽)-클라이언트(요청하는 쪽)

DB 백엔드 서버단

일관성 유지, 복구, 동시접근 제어 매우 중요

데이터 중복줄이기 중요, 표준화, 무결성(결함이 없어야함) 유지

데이터 저장 -DBMS 사용 MySQL

DBA :  정의어 조작어 제어어
고객 : 몰라도됨
SQL 사용자 :  조작어 특히 조회
프로그래머 : 정의어 조작어

이름,출판사?
select  	 bookname, publisher (요구하는 정보)
from  	 book ; (테이블 이름, 어느 테이블에서 검색을 하겠느냐) > 전체를 다 뿌리려면? select * from book;
키워드 	 식별자
예약어

예약어(豫約語, 영어: reserved word)는 컴퓨터 프로그래밍 언어에서 이미 문법적인 용도로 사용되고 있기 때문에 식별자로 사용할 수 없는 단어 
예를 들어 C에서 return은 변수명이나 함수명으로 사용할 수 없다. 그런 단어들은 키워드이다.

식별자(識別子, identifier)는 어떤 대상을 유일하게 식별 및 구별할 수 있는 이름

이름,출판사 검색, 가격 10000원 이상
select  	 bookname, publisher (요구하는 정보)
from  	 book (테이블 이름, 어느 테이블에서 검색을 하겠느냐)
where      price                >=              10000; (검색조건. 조건절, where절 > 예약어)
             필드명(컬럼명)  비교연산자      기준값

레코드 =행(row)
데이터 입출력의 단위는 기본적으로 레코드(행)

필드=열, 컬럼

역순 정렬 : order by 컬럼명 desc
오름차순 정렬 : order by 컬럼명 asc ( > 디폴트라 쓸일 별로 없음.)

DBMS의 기능
데이터 정의
데이터 조작
데이터 추출 select
데이터 제어 사용자생성,권한제어,백업,회복,동시성

==================================================================================

데이터베이스 구축
1 정보 모델링 ER다이어그램
2 데이터 모델링 관계 데이터 모델
3 DB로 구현(현실세계와 일치해야함)

데이터베이스 모델링

현실세계에서 사용되는 작업, 사물을 데이터베이스 개체로 변환하는 과정
테이블로 변환
테이블-데이터베이스 내에서 데이터를 저장하는 개체. 파일이나 시트와 같은 개념

ex 제품의 거래를 모델링하고, 모델링의 결과를 MYSQL을 이용하여 데이터베이스로 구축하는 과정

문제 > 반복이나 중복이 생김.

중복을 위해서 테이블을 쪼갤 때 쪼개기 전의 기능을 가지고 있어야함. > 외래키를 이용하여 참조할 수 있계 관계를 줘야함.

정규화 > 가장 큰 목적 : 중복 제거(최소화. 중복이 없을 순 없다.)

관계 데이터 모델

개념
무결성 제약조건
관계대수

* 릴레이션-행과 열로 구성된 '테이블' 이 때는 관계라고는 하지 않음.

각 원소 한개씩 선택하여 만들어진것이 관계(relationship)를 맺고있다.

릴레이션 스키마와 인스턴스

튜플= 레코드= 행
**카디날리티 1:n 관계된 테이블(행)의 수를 이야기 할 때 씀.
필드=애트리뷰트(속성)=컬럼 
디그리(차수)=컬럼의 수
스키마=테이블=구조
인스터스=행의 데이터

스키마의 요소 속성 : 릴레이션 스키마의 열/도메인 : 속성이 가질 수 있는 값의 집합(하나의 컬럼을 다 긁어온 것, 범위,종류)/차수 : 속성의 개수
스키마 표현: 릴레이션 이름(속성1:도메인1,속성2:도메인2,...) 도서(도서번호,이름,..)

인스턴스의 요소 투플:릴레이션의 행/카디날리티:튜플의 수(관계된)

릴레이션의 특징
속성은 단일 값을 가진다. 복합 값 안됨. ex연락처-집번호,폰번호 둘다 있음 > 복합 값
속성은 서로 다른 이름을 가진다.
한 속성의 값은 모두 같은 도메인 값을 가진다.
속성의 순서는 상관없다 > 일반적으로 키를 먼저 쓰기는 함.
릴레이션 내에서 중복된 투플은 허용하지 않는다. 모든 투플은 서로 값이 달라야한다.
투플의 순서는 상관없다.

무결성 제약조건

키
특정 투플을 식별할 때 사용하는 속성 혹은 속성의 집합
릴레이션에서 중복 투플은 허용하지 않음.
값이 달라야함.
키는 관계를 맺는데도 사용됨 상대편에서 FK가 됨.

슈퍼키 후보키 외래키 대체키 기본키

기본키 외래키 중요

후보키 투플을 유일하게 식별할 수 있는 속성의 최소 집합
기본키 투플을 식별할 수 있는 고유한 값을 가져야함. 반드시 있다.(NULL 값x).변동이 적어야함. ex폰번호-안됨. 없을 수 있고. 바뀔 수 있음. 기본키는 밑줄 그어 표시.
외래키 다른 릴레이션의 기본키를 참조하는 속성. 다른 릴레이션의 기본키를 참조하여 관계 데이터 모델의 특징인 '관계'를 표현함. Null,중복허용. 자기가 자신을 참조 가능.ex사번 직장상사

=======================
부호 없음 +값만 취급
decimal(7,0) (길이,소숫점) 
unsigned 부호없음 
default 0 값을 넣지 않더라도 기본으로 들어감 null X
enum 리스트중 하나 선택 
enum('Y','N') default 'Y' y나 n중에 선택해서 들어가고 디폴트 y

DATE - format YYYY-MM-DD
DATETIME - format: YYYY-MM-DD HH:MI:SS

CURRENT_TIMESTAMP() 시스템 날짜 입력해줌

컬럼추가
ALTER TABLE table_name
ADD column_name datatype; 

컬럼삭제
ALTER TABLE table_name
DROP COLUMN column_name;

사용하는 dbms에 따라 명령어가 다를 수 있음. 버전에 따라서도 차이가 날 수 있음.

기본키 고유한 값, null값 허용 x

릴레이션 언더바 약속

외래키 
**릴레이션간의 관계를 표현함. 
다른 릴레이션의 기본키를 참조하는 속성. 
참조되는 기본키의 값이 변경되면 참조하는 외래키의 값도 변경됨.
도메인이 서로 같아야함.
null, 중복 허용.
자기 자신의 기본키를 참조 가능.

무결성(데이터 도메인 참조 개체)
일관성과 정확성

개체무결성
(=기본키 제약) 유일, 널 안됨
삽입 기본키 값이 같으면 안됨
수정 기본키 값이 같거나 널로도 수정 금지
삭제 특별한 확인이 필요하지 않으며 즉시 수행, 그러나 관련있는 릴레이션이 있는 경우에는 삭제 할 수 없음.
디비가 알아서 해줌 신경 쓸 필요는 없음.

참조무결성
=외래키 제약
릴레이션 간의 참조 관계를 선언하는 제약조건
자식 릴레이션의 외래키는 부모 릴레이션의 기본키와 도메인이 동일해야함
외래키가 있는 곳이 자식 릴레이션
자식 릴레이션의 값이 변경될 때 부모 릴레이션의 도메인 제약을 받음
삽입 
자식 릴레이션에 참조받는 테이블에 외래키 값이 없는 항목은 삽입이 금지된다.
부모 릴레이션에 추가하는 것은 무방함.
삭제
자식 릴레이션 문제없음
부모 릴레이션 문제됨. 자식 릴레이션에서 참조하는데 문제생김. 지우려면 자식 릴레이션에도 같이 지워야함.

		


도메인무결성
각가 지정된 값만 가져야함.

CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    CONSTRAINT PK_Person PRIMARY KEY (ID,LastName) 제약조건을 이름을 정해서 걸기도함.
);

ALTER TABLE Persons
ADD PRIMARY KEY (ID); 기존의 id에 프라이머리키 추가하는 방식

순서상 부모 릴레이션 >자식 릴레이션 입력도 이 순으로

부모 자식 컬럼명은 달라도 데이터타입은 같아야함(도메인이 같아야 하기 때문에)

CREATE TABLE Orders (
    OrderID int NOT NULL,
    OrderNumber int NOT NULL,
    PersonID int,  > 부모 자식 컬럼명은 달라도 데이터타입은 같아야함(도메인이 같아야 하기 때문에)
    PRIMARY KEY (OrderID),
    FOREIGN KEY (PersonID) REFERENCES Persons(PersonID) >fk설정하는 방법
);

부모 테이블의 기본키를 자식 테이블에 넣으면 관계 발생

관계대수식
릴레이션 간 연산을 통해 결과 릴레이션을 찾는 절차를 기술한 언어
릴레이션과 연산자로 구성
결과는 릴레이션으로 반환
단항 연산자<조건> 릴레이션
이항 릴리에선 연산자<조건> 릴레이션2   <조건>where절

셀렉션 시그마기호 단항연산자 조건에 맞는 투플 추출 행단위 추출 조건 명시
프로젝션 파이기호 단항연산자 조건에 맞는 속성 추출 열단위 추출 조건 속성리스트

SELECT DISTINCT 중복되는 튜플 하나만 보여줌 count와 함께도 사용 가능
SELECT COUNT(DISTINCT country)
FROM Customers;

AS 별칭

SELECT CONCAT(first_name, ' ', last_name) AS full_name
FROM Customers;

CONCAT 이어붙일때

BETWEEN 범위 문자 가능

COUNT 갯수

GROUP BY 같은것 끼리 묶음

HAVING >조건

SELECT COUNT(customer_id), country
FROM Customers
GROUP BY country
>>>>>group by의 조건절 HAVING COUNT(customer_id) > 1;


SELECT Customers.customer_id, Customers.first_name, Count(Orders.order_id) AS order_count
             테이블.컬럼명 >두개 테이블로 쓰기 때문에 테이블명이 들어감.
FROM Customers LEFT JOIN Orders >조인방식 왼쪽 테이블의 튜플은 다 뿌려줌
ON Customers.customer_id = Orders.customer_id>조인조건
GROUP BY Customers.customer_id;

select distinct 튜플명 >중복 제거
count입히면 튜플 수

======================================================

[ ]한개일치
[^]한개 불일치

~별 group by

having절에는 집계함수가 와야함(sum avg max min count와 같은)

조인
튜플 고객 다섯개 주문 열개
5*10 50개

======================================================
inner join 동등조인 컬럼명은 다를 수있고 데이터타입은 같음.
UNION 합집합 컬럼이 같아야 가능

create 문
테이블 구성, 속성과 속성에 관한 제약 정의, 기본키 및 외래키를 정릐하는 명령
on update on delete 외래키 속성의 수정과 투플 삭제 시 동작을 나타냄
not null 
default 
check 범위 제약
복합키(not null, 유일) > 하나로 조건을 만족하지 못할 때 두개로 만족하면 잡을 수 있음
on delete cascade 연쇄 삭제 

데이터 조작어 dml, crud
insert update delete select 데이터가 변경되는것 삽입 수정 삭제
insert into와 velue 매치 되어야함 
	> 덜써야 한다면 그 항목을 제외하고 속성 리스트 적어줘야함.



=================================================================
0308

개념적 데이터 모델에서 나온 산출물 > E-R모델

왜 리버스와 포워드로 구분?
원칙은 다이어그램 > 테이블 포워드 <--> 리버스
  
1단계 요구사항에서 엔티티 걸러내고 > 속성 찾고 > 관계 찾고
2단계 개념적 db설계
3단계 논리적 설계 1) 모든개체 릴레이션으로 변환 > 2)다대다 릴레이션으로 변환 양쪽키 가져옴 외래키
두개를 엮어서 복합키로 기본키 설정 가능 혹은 수강신청번호와 같이 별도로 부여해서 기본키 설정하는것도 
가능함/ 외래키는 조인을 위한 역할> 
3) 일대일, 일대다는 외래키로 표현 : 어디 속성을 어디에 넣어야함. 상대방의 기본키를 가져와서
집어 넣어 관계를 만들어준다 어디에 넣어서 어떻게 설정할지 생각해봐야함. 중복이 생기지 않도록 주의.
일대다에서 일의 키를 다에 외래키로 넣어주면 중복방지 가능 / 일대일은 아무쪽에 넣어도 문제가 생기지
않는다. > 4) 다중값 속성은 릴레이션으로 변환

>>>>정규화는 무결성 강화를 위한 과정?

정규화를 단계별로 모두 밟을 필요는 없지만 해당하는지 확인후 반드시 거쳐야함.
이상현상 방지.



  









	


